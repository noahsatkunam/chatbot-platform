// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  SUPER_ADMIN
  TENANT_ADMIN
  TENANT_USER
  END_USER
}

enum TokenType {
  REFRESH
  PASSWORD_RESET
  EMAIL_VERIFICATION
}

enum TenantStatus {
  TRIAL
  ACTIVE
  SUSPENDED
  INACTIVE
}

enum TenantPlan {
  FREE
  STARTER
  PROFESSIONAL
  ENTERPRISE
}

enum DocumentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum PresenceStatus {
  ONLINE
  OFFLINE
  AWAY
  BUSY
}

model Tenant {
  id                String          @id @default(uuid())
  name              String
  slug              String          @unique
  status            TenantStatus    @default(TRIAL)
  settings          Json            @default("{}")
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  users             User[]
  knowledgeDocuments KnowledgeDocument[]
  knowledgeCollection KnowledgeCollection?
  retrievalLogs     RetrievalLog[]
  conversations     Conversation[]
  processingJobs    ProcessingJob[]
  searchAnalytics   SearchAnalytics[]
  kbSettings        KnowledgeBaseSettings?
  
  @@index([slug])
  @@index([status])
  @@map("tenants")
}

model User {
  id                    String    @id @default(uuid())
  email                 String
  password              String
  firstName             String?
  lastName              String?
  fullName              String?
  avatar                String?
  avatarUrl             String?
  role                  Role      @default(END_USER)
  isActive              Boolean   @default(true)
  emailVerified         Boolean   @default(false)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  tenantId              String?

  // Relations
  tenant                Tenant?                   @relation(fields: [tenantId], references: [id], onDelete: SetNull)
  knowledgeDocuments    KnowledgeDocument[]
  retrievalLogs         RetrievalLog[]
  participations        ConversationParticipant[]
  messages              Message[]
  reactions             MessageReaction[]
  processingJobs        ProcessingJob[]
  searchAnalytics       SearchAnalytics[]
  documentVersions      DocumentVersion[]

  @@unique([email, tenantId])
  @@index([email])
  @@index([tenantId])
  @@index([role])
  @@map("users")
}

// Knowledge Base Models
model KnowledgeDocument {
  id             String   @id @default(cuid())
  tenantId       String
  filename       String
  originalName   String
  fileSize       Int
  mimeType       String
  status         DocumentStatus @default(PROCESSING)
  processingProgress Int @default(0)
  metadata       Json?
  uploadedBy     String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  processedAt    DateTime?
  errorMessage   String?

  tenant    Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  uploader  User             @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)
  chunks    DocumentChunk[]
  versions  DocumentVersion[]

  @@index([tenantId])
  @@index([status])
  @@index([uploadedBy])
  @@index([createdAt])
  @@map("knowledge_documents")
}

model DocumentChunk {
  id             String   @id @default(cuid())
  documentId     String
  tenantId       String
  content        String   @db.Text
  chunkIndex     Int
  startOffset    Int
  endOffset      Int
  tokenCount     Int
  embeddingId    String?
  metadata       Json?
  createdAt      DateTime @default(now())

  document KnowledgeDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([tenantId])
  @@index([documentId])
  @@index([embeddingId])
  @@map("document_chunks")
}

model KnowledgeCollection {
  id             String   @id @default(cuid())
  tenantId       String   @unique
  collectionName String
  vectorDimension Int     @default(1536)
  distanceMetric String  @default("cosine")
  settings       Json?
  documentCount  Int     @default(0)
  totalChunks    Int     @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([collectionName])
  @@map("knowledge_collections")
}

model EmbeddingCache {
  id           String   @id @default(cuid())
  textHash     String   @unique
  model        String
  embedding    Json     // Store as JSON array
  tokenCount   Int
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @default(now())

  @@index([textHash])
  @@index([model])
  @@index([lastUsedAt])
  @@map("embedding_cache")
}

model RetrievalLog {
  id            String   @id @default(cuid())
  tenantId      String
  userId        String?
  query         String   @db.Text
  queryType     String   @default("semantic")
  resultsCount  Int
  responseTime  Int      // milliseconds
  metadata      Json?
  createdAt     DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId])
  @@index([queryType])
  @@index([createdAt])
  @@map("retrieval_logs")
}

// Enhanced Knowledge Base Models
model ProcessingJob {
  id            String   @id @default(cuid())
  tenantId      String
  userId        String
  jobType       String   // "document_upload", "batch_process", "reprocess"
  status        String   @default("pending") // "pending", "processing", "completed", "failed"
  progress      Int      @default(0) // 0-100
  totalItems    Int      @default(1)
  processedItems Int     @default(0)
  errorMessage  String?
  metadata      Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  completedAt   DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("processing_jobs")
}

model DocumentVersion {
  id           String   @id @default(cuid())
  documentId   String
  version      Int
  filename     String
  fileSize     Int
  contentHash  String
  changes      String?  @db.Text
  metadata     Json?
  createdAt    DateTime @default(now())
  createdBy    String

  document KnowledgeDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  creator  User              @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@unique([documentId, version])
  @@index([documentId])
  @@index([createdAt])
  @@map("document_versions")
}

model SearchAnalytics {
  id            String   @id @default(cuid())
  tenantId      String
  userId        String?
  query         String   @db.Text
  queryHash     String
  resultsCount  Int
  clickthrough  Int      @default(0)
  responseTime  Int
  searchType    String   @default("semantic")
  filters       Json?
  metadata      Json?
  createdAt     DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId])
  @@index([queryHash])
  @@index([createdAt])
  @@map("search_analytics")
}

model KnowledgeBaseSettings {
  id                String   @id @default(cuid())
  tenantId          String   @unique
  chunkingStrategy  String   @default("semantic") // "semantic", "hierarchical", "overlapping"
  chunkSize         Int      @default(1000)
  chunkOverlap      Int      @default(200)
  searchConfig      Json     @default("{}")
  processingConfig  Json     @default("{}")
  indexingConfig    Json     @default("{}")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@map("kb_settings")
}

// Core Chat Models
model Conversation {
  id          String   @id @default(cuid())
  tenantId    String
  title       String?
  isGroup     Boolean  @default(false)
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant       Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  messages     Message[]
  participants ConversationParticipant[]

  @@index([tenantId])
  @@index([createdAt])
  @@map("conversations")
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  tenantId       String
  role           String   @default("member")
  joinedAt       DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@index([tenantId])
  @@map("conversation_participants")
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  userId         String
  tenantId       String
  content        String   @db.Text
  type           String   @default("text")
  metadata       Json?
  deleted        Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  reactions    MessageReaction[]

  @@index([conversationId])
  @@index([userId])
  @@index([tenantId])
  @@index([createdAt])
  @@map("messages")
}

model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  tenantId  String
  reaction  String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, reaction])
  @@index([messageId])
  @@index([userId])
  @@index([tenantId])
  @@map("message_reactions")
}
